# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:28:03+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AccessPointArn(
    RootModel[constr(pattern=r'arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*')]
):
    root: constr(pattern=r'arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*')


class AccessPointPolicy(RootModel[str]):
    root: str


class AccessPreviewFindingId(RootModel[str]):
    root: str


class AccessPreviewId(
    RootModel[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ]
):
    root: constr(
        pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class AccessPreviewStatus(Enum):
    COMPLETED = 'COMPLETED'
    CREATING = 'CREATING'
    FAILED = 'FAILED'


class AccessPreviewStatusReasonCode(Enum):
    INTERNAL_ERROR = 'INTERNAL_ERROR'
    INVALID_CONFIGURATION = 'INVALID_CONFIGURATION'


class AclCanonicalId(RootModel[str]):
    root: str


class AclPermission(Enum):
    READ = 'READ'
    WRITE = 'WRITE'
    READ_ACP = 'READ_ACP'
    WRITE_ACP = 'WRITE_ACP'
    FULL_CONTROL = 'FULL_CONTROL'


class AclUri(RootModel[str]):
    root: str


class AnalyzerArn(
    RootModel[constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}')]
):
    root: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}')


class AnalyzerStatus(Enum):
    ACTIVE = 'ACTIVE'
    CREATING = 'CREATING'
    DISABLED = 'DISABLED'
    FAILED = 'FAILED'


class Boolean(RootModel[bool]):
    root: bool


class CancelPolicyGenerationRequest(BaseModel):
    pass


class CancelPolicyGenerationResponse(BaseModel):
    pass


class CloudTrailArn(
    RootModel[constr(pattern=r'arn:[^:]*:cloudtrail:[^:]*:[^:]*:trail/.{1,576}')]
):
    root: constr(pattern=r'arn:[^:]*:cloudtrail:[^:]*:[^:]*:trail/.{1,576}')


class ConfigurationsMapKey(RootModel[str]):
    root: str


class ConflictException(RootModel[Any]):
    root: Any


class CreateAccessPreviewResponse(BaseModel):
    id: AccessPreviewId


class CreateAnalyzerResponse(BaseModel):
    arn: Optional[AnalyzerArn] = None


class DeleteAnalyzerRequest(BaseModel):
    pass


class DeleteArchiveRuleRequest(BaseModel):
    pass


class EbsGroup(RootModel[str]):
    root: str


class EbsGroupList(RootModel[List[EbsGroup]]):
    root: List[EbsGroup]


class EbsSnapshotDataEncryptionKeyId(RootModel[str]):
    root: str


class EbsUserId(RootModel[str]):
    root: str


class EbsUserIdList(RootModel[List[EbsUserId]]):
    root: List[EbsUserId]


class EcrRepositoryPolicy(RootModel[str]):
    root: str


class EfsFileSystemPolicy(RootModel[str]):
    root: str


class FindingChangeType(Enum):
    CHANGED = 'CHANGED'
    NEW = 'NEW'
    UNCHANGED = 'UNCHANGED'


class FindingId(RootModel[str]):
    root: str


class FindingIdList(RootModel[List[FindingId]]):
    root: List[FindingId]


class FindingSourceType(Enum):
    POLICY = 'POLICY'
    BUCKET_ACL = 'BUCKET_ACL'
    S3_ACCESS_POINT = 'S3_ACCESS_POINT'
    S3_ACCESS_POINT_ACCOUNT = 'S3_ACCESS_POINT_ACCOUNT'


class FindingStatus(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'
    RESOLVED = 'RESOLVED'


class FindingStatusUpdate(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'


class GetAccessPreviewRequest(BaseModel):
    pass


class GetAnalyzedResourceRequest(BaseModel):
    pass


class GetAnalyzerRequest(BaseModel):
    pass


class GetArchiveRuleRequest(BaseModel):
    pass


class GetFindingRequest(BaseModel):
    pass


class GetGeneratedPolicyRequest(BaseModel):
    pass


class GranteePrincipal(RootModel[str]):
    root: str


class IamTrustPolicy(RootModel[str]):
    root: str


class Integer(RootModel[int]):
    root: int


class InternalServerException(RootModel[Any]):
    root: Any


class InternetConfiguration(BaseModel):
    pass


class IssueCode(RootModel[str]):
    root: str


class IssuingAccount(RootModel[str]):
    root: str


class JobErrorCode(Enum):
    AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR'
    RESOURCE_NOT_FOUND_ERROR = 'RESOURCE_NOT_FOUND_ERROR'
    SERVICE_QUOTA_EXCEEDED_ERROR = 'SERVICE_QUOTA_EXCEEDED_ERROR'
    SERVICE_ERROR = 'SERVICE_ERROR'


class JobId(RootModel[str]):
    root: str


class JobStatus(Enum):
    IN_PROGRESS = 'IN_PROGRESS'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    CANCELED = 'CANCELED'


class KmsConstraintsKey(RootModel[str]):
    root: str


class KmsConstraintsValue(RootModel[str]):
    root: str


class KmsGrantOperation(Enum):
    CreateGrant = 'CreateGrant'
    Decrypt = 'Decrypt'
    DescribeKey = 'DescribeKey'
    Encrypt = 'Encrypt'
    GenerateDataKey = 'GenerateDataKey'
    GenerateDataKeyPair = 'GenerateDataKeyPair'
    GenerateDataKeyPairWithoutPlaintext = 'GenerateDataKeyPairWithoutPlaintext'
    GenerateDataKeyWithoutPlaintext = 'GenerateDataKeyWithoutPlaintext'
    GetPublicKey = 'GetPublicKey'
    ReEncryptFrom = 'ReEncryptFrom'
    ReEncryptTo = 'ReEncryptTo'
    RetireGrant = 'RetireGrant'
    Sign = 'Sign'
    Verify = 'Verify'


class KmsGrantOperationsList(RootModel[List[KmsGrantOperation]]):
    root: List[KmsGrantOperation]


class KmsKeyPolicy(RootModel[str]):
    root: str


class LearnMoreLink(RootModel[str]):
    root: str


class ListAccessPreviewsRequest(BaseModel):
    pass


class ListAnalyzersRequest(BaseModel):
    pass


class ListArchiveRulesRequest(BaseModel):
    pass


class ListPolicyGenerationsRequest(BaseModel):
    pass


class ListPolicyGenerationsRequestMaxResultsInteger(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class ListTagsForResourceRequest(BaseModel):
    pass


class Locale(Enum):
    DE = 'DE'
    EN = 'EN'
    ES = 'ES'
    FR = 'FR'
    IT = 'IT'
    JA = 'JA'
    KO = 'KO'
    PT_BR = 'PT_BR'
    ZH_CN = 'ZH_CN'
    ZH_TW = 'ZH_TW'


class Name(
    RootModel[constr(pattern=r'[A-Za-z][A-Za-z0-9_.-]*', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[A-Za-z][A-Za-z0-9_.-]*', min_length=1, max_length=255)


class OrderBy(Enum):
    ASC = 'ASC'
    DESC = 'DESC'


class PolicyDocument(RootModel[str]):
    root: str


class PolicyName(RootModel[str]):
    root: str


class PolicyType(Enum):
    IDENTITY_POLICY = 'IDENTITY_POLICY'
    RESOURCE_POLICY = 'RESOURCE_POLICY'
    SERVICE_CONTROL_POLICY = 'SERVICE_CONTROL_POLICY'


class Position(BaseModel):
    column: Integer
    line: Integer
    offset: Integer


class PrincipalArn(
    RootModel[constr(pattern=r'arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}')]
):
    root: constr(pattern=r'arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}')


class RdsDbClusterSnapshotAccountId(RootModel[str]):
    root: str


class RdsDbClusterSnapshotAccountIdsList(
    RootModel[List[RdsDbClusterSnapshotAccountId]]
):
    root: List[RdsDbClusterSnapshotAccountId]


class RdsDbClusterSnapshotAttributeName(RootModel[str]):
    root: str


class RdsDbClusterSnapshotAttributeValue(BaseModel):
    accountIds: Optional[RdsDbClusterSnapshotAccountIdsList] = None


class RdsDbClusterSnapshotAttributesMap(
    RootModel[Optional[Dict[str, RdsDbClusterSnapshotAttributeValue]]]
):
    root: Optional[Dict[str, RdsDbClusterSnapshotAttributeValue]] = None


class RdsDbClusterSnapshotKmsKeyId(RootModel[str]):
    root: str


class RdsDbSnapshotAccountId(RootModel[str]):
    root: str


class RdsDbSnapshotAccountIdsList(RootModel[List[RdsDbSnapshotAccountId]]):
    root: List[RdsDbSnapshotAccountId]


class RdsDbSnapshotAttributeName(RootModel[str]):
    root: str


class RdsDbSnapshotAttributeValue(BaseModel):
    accountIds: Optional[RdsDbSnapshotAccountIdsList] = None


class RdsDbSnapshotAttributesMap(
    RootModel[Optional[Dict[str, RdsDbSnapshotAttributeValue]]]
):
    root: Optional[Dict[str, RdsDbSnapshotAttributeValue]] = None


class RdsDbSnapshotKmsKeyId(RootModel[str]):
    root: str


class ReasonCode(Enum):
    AWS_SERVICE_ACCESS_DISABLED = 'AWS_SERVICE_ACCESS_DISABLED'
    DELEGATED_ADMINISTRATOR_DEREGISTERED = 'DELEGATED_ADMINISTRATOR_DEREGISTERED'
    ORGANIZATION_DELETED = 'ORGANIZATION_DELETED'
    SERVICE_LINKED_ROLE_CREATION_FAILED = 'SERVICE_LINKED_ROLE_CREATION_FAILED'


class ResourceArn(RootModel[constr(pattern=r'arn:[^:]*:[^:]*:[^:]*:[^:]*:.*')]):
    root: constr(pattern=r'arn:[^:]*:[^:]*:[^:]*:[^:]*:.*')


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourceType(Enum):
    AWS__S3__Bucket = 'AWS::S3::Bucket'
    AWS__IAM__Role = 'AWS::IAM::Role'
    AWS__SQS__Queue = 'AWS::SQS::Queue'
    AWS__Lambda__Function = 'AWS::Lambda::Function'
    AWS__Lambda__LayerVersion = 'AWS::Lambda::LayerVersion'
    AWS__KMS__Key = 'AWS::KMS::Key'
    AWS__SecretsManager__Secret = 'AWS::SecretsManager::Secret'
    AWS__EFS__FileSystem = 'AWS::EFS::FileSystem'
    AWS__EC2__Snapshot = 'AWS::EC2::Snapshot'
    AWS__ECR__Repository = 'AWS::ECR::Repository'
    AWS__RDS__DBSnapshot = 'AWS::RDS::DBSnapshot'
    AWS__RDS__DBClusterSnapshot = 'AWS::RDS::DBClusterSnapshot'
    AWS__SNS__Topic = 'AWS::SNS::Topic'


class RetiringPrincipal(RootModel[str]):
    root: str


class RoleArn(RootModel[constr(pattern=r'arn:[^:]*:iam::[^:]*:role/.{1,576}')]):
    root: constr(pattern=r'arn:[^:]*:iam::[^:]*:role/.{1,576}')


class S3BucketPolicy(RootModel[str]):
    root: str


class S3PublicAccessBlockConfiguration(BaseModel):
    ignorePublicAcls: Boolean
    restrictPublicBuckets: Boolean


class SecretsManagerSecretKmsId(RootModel[str]):
    root: str


class SecretsManagerSecretPolicy(RootModel[str]):
    root: str


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class SnsTopicPolicy(RootModel[constr(min_length=0, max_length=30720)]):
    root: constr(min_length=0, max_length=30720)


class Span(BaseModel):
    end: Position
    start: Position


class SqsQueuePolicy(RootModel[str]):
    root: str


class StartPolicyGenerationResponse(BaseModel):
    jobId: JobId


class StatusReason(BaseModel):
    code: ReasonCode


class String(RootModel[str]):
    root: str


class Substring(BaseModel):
    length: Integer
    start: Integer


class TagKeys(RootModel[List[String]]):
    root: List[String]


class TagResourceResponse(BaseModel):
    pass


class TagsMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class ThrottlingException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class Token(RootModel[str]):
    root: str


class Type(Enum):
    ACCOUNT = 'ACCOUNT'
    ORGANIZATION = 'ORGANIZATION'


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UpdateFindingsRequest(BaseModel):
    analyzerArn: AnalyzerArn
    clientToken: Optional[String] = None
    ids: Optional[FindingIdList] = None
    resourceArn: Optional[ResourceArn] = None
    status: FindingStatusUpdate


class ValidatePolicyFindingType(Enum):
    ERROR = 'ERROR'
    SECURITY_WARNING = 'SECURITY_WARNING'
    SUGGESTION = 'SUGGESTION'
    WARNING = 'WARNING'


class ValidatePolicyResourceType(Enum):
    AWS__S3__Bucket = 'AWS::S3::Bucket'
    AWS__S3__AccessPoint = 'AWS::S3::AccessPoint'
    AWS__S3__MultiRegionAccessPoint = 'AWS::S3::MultiRegionAccessPoint'
    AWS__S3ObjectLambda__AccessPoint = 'AWS::S3ObjectLambda::AccessPoint'
    AWS__IAM__AssumeRolePolicyDocument = 'AWS::IAM::AssumeRolePolicyDocument'


class ValidationException(RootModel[Any]):
    root: Any


class ValueList(RootModel[List[String]]):
    root: List[String] = Field(..., max_length=20, min_length=1)


class VpcId(RootModel[constr(pattern=r'vpc-([0-9a-f]){8}(([0-9a-f]){9})?')]):
    root: constr(pattern=r'vpc-([0-9a-f]){8}(([0-9a-f]){9})?')


class AnalyzedResourcePostRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to retrieve a list of analyzed resources from.',
        )
    )
    maxResults: Optional[int] = Field(
        None, description='The maximum number of results to return in the response.'
    )
    nextToken: Optional[str] = Field(
        None, description='A token used for pagination of results returned.'
    )
    resourceType: Optional[ResourceType] = Field(
        None, description='The type of resource.'
    )


class ArchiveRulePutRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(..., description='The Amazon resource name (ARN) of the analyzer.')
    )
    clientToken: Optional[str] = Field(None, description='A client token.')
    ruleName: constr(
        pattern=r'[A-Za-z][A-Za-z0-9_.-]*', min_length=1, max_length=255
    ) = Field(..., description='The name of the rule to apply.')


class Sort(BaseModel):
    attributeName: Optional[String] = None
    orderBy: Optional[OrderBy] = None


class Status(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'


class FindingPutRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> that generated the findings to update.',
        )
    )
    clientToken: Optional[str] = Field(None, description='A client token.')
    ids: Optional[List[FindingId]] = Field(
        None, description='The IDs of the findings to update.'
    )
    resourceArn: Optional[constr(pattern=r'arn:[^:]*:[^:]*:[^:]*:[^:]*:.*')] = Field(
        None, description='The ARN of the resource identified in the finding.'
    )
    status: Status = Field(
        ...,
        description='The state represents the action to take to update the finding Status. Use <code>ARCHIVE</code> to change an Active finding to an Archived finding. Use <code>ACTIVE</code> to change an Archived finding to an Active finding.',
    )


class PolicyGenerationDetails1(BaseModel):
    principalArn: Optional[PrincipalArn] = None


class PolicyValidationPostRequest(BaseModel):
    locale: Optional[Locale] = Field(
        None, description='The locale to use for localizing the findings.'
    )
    policyDocument: str = Field(
        ...,
        description='The JSON policy document to use as the content for the policy.',
    )
    policyType: PolicyType = Field(
        ...,
        description='<p>The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. They also include service-control policies (SCPs) that are attached to an Amazon Web Services organization, organizational unit (OU), or an account.</p> <p>Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy. </p>',
    )
    validatePolicyResourceType: Optional[ValidatePolicyResourceType] = Field(
        None,
        description='<p>The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is <code>RESOURCE_POLICY</code>. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose <code>AWS::S3::Bucket</code> for the policy validation resource type.</p> <p>For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.</p>',
    )


class ResourceScanPostRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to use to scan the policies applied to the specified resource.',
        )
    )
    resourceArn: constr(pattern=r'arn:[^:]*:[^:]*:[^:]*:[^:]*:.*') = Field(
        ..., description='The ARN of the resource to scan.'
    )
    resourceOwnerAccount: Optional[str] = Field(
        None,
        description='The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.',
    )


class TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, String] = Field(..., description='The tags to add to the resource.')


class AccessPreviewStatusReason(BaseModel):
    code: AccessPreviewStatusReasonCode


class AccessPreviewSummary(BaseModel):
    analyzerArn: AnalyzerArn
    createdAt: Timestamp
    id: AccessPreviewId
    status: AccessPreviewStatus
    statusReason: Optional[AccessPreviewStatusReason] = None


class AccessPreviewsList(RootModel[List[AccessPreviewSummary]]):
    root: List[AccessPreviewSummary]


class AclGrantee(BaseModel):
    id: Optional[AclCanonicalId] = None
    uri: Optional[AclUri] = None


class ActionList(RootModel[List[String]]):
    root: List[String]


class AnalyzedResourceSummary(BaseModel):
    resourceArn: ResourceArn
    resourceOwnerAccount: String
    resourceType: ResourceType


class AnalyzedResourcesList(RootModel[List[AnalyzedResourceSummary]]):
    root: List[AnalyzedResourceSummary]


class AnalyzerSummary(BaseModel):
    arn: AnalyzerArn
    createdAt: Timestamp
    lastResourceAnalyzed: Optional[String] = None
    lastResourceAnalyzedAt: Optional[Timestamp] = None
    name: Name
    status: AnalyzerStatus
    statusReason: Optional[StatusReason] = None
    tags: Optional[TagsMap] = None
    type: Type


class AnalyzersList(RootModel[List[AnalyzerSummary]]):
    root: List[AnalyzerSummary]


class ApplyArchiveRuleRequest(BaseModel):
    analyzerArn: AnalyzerArn
    clientToken: Optional[String] = None
    ruleName: Name


class ConditionKeyMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class Criterion(BaseModel):
    contains: Optional[ValueList] = None
    eq: Optional[ValueList] = None
    exists: Optional[Boolean] = None
    neq: Optional[ValueList] = None


class EbsSnapshotConfiguration(BaseModel):
    groups: Optional[EbsGroupList] = None
    kmsKeyId: Optional[EbsSnapshotDataEncryptionKeyId] = None
    userIds: Optional[EbsUserIdList] = None


class EcrRepositoryConfiguration(BaseModel):
    repositoryPolicy: Optional[EcrRepositoryPolicy] = None


class EfsFileSystemConfiguration(BaseModel):
    fileSystemPolicy: Optional[EfsFileSystemPolicy] = None


class FilterCriteriaMap(RootModel[Optional[Dict[str, Criterion]]]):
    root: Optional[Dict[str, Criterion]] = None


class FindingSourceDetail(BaseModel):
    accessPointAccount: Optional[String] = None
    accessPointArn: Optional[String] = None


class GeneratedPolicy(BaseModel):
    policy: String


class GeneratedPolicyList(RootModel[List[GeneratedPolicy]]):
    root: List[GeneratedPolicy]


class GeneratedPolicyResult(BaseModel):
    generatedPolicies: Optional[GeneratedPolicyList] = None
    properties: Any = Field(
        ...,
        description='A <code>GeneratedPolicyProperties</code> object that contains properties of the generated policy.',
    )


class GetAnalyzerResponse(BaseModel):
    analyzer: AnalyzerSummary


class IamRoleConfiguration(BaseModel):
    trustPolicy: Optional[IamTrustPolicy] = None


class InlineArchiveRule(BaseModel):
    filter: FilterCriteriaMap
    ruleName: Name


class InlineArchiveRulesList(RootModel[List[InlineArchiveRule]]):
    root: List[InlineArchiveRule]


class JobError(BaseModel):
    code: JobErrorCode
    message: String


class KmsConstraintsMap(RootModel[Optional[Dict[str, KmsConstraintsValue]]]):
    root: Optional[Dict[str, KmsConstraintsValue]] = None


class KmsGrantConstraints(BaseModel):
    encryptionContextEquals: Optional[KmsConstraintsMap] = None
    encryptionContextSubset: Optional[KmsConstraintsMap] = None


class KmsKeyPoliciesMap(RootModel[Optional[Dict[str, KmsKeyPolicy]]]):
    root: Optional[Dict[str, KmsKeyPolicy]] = None


class ListAccessPreviewFindingsRequest(BaseModel):
    analyzerArn: AnalyzerArn
    filter: Optional[FilterCriteriaMap] = None
    maxResults: Optional[Integer] = None
    nextToken: Optional[Token] = None


class ListAccessPreviewsResponse(BaseModel):
    accessPreviews: AccessPreviewsList
    nextToken: Optional[Token] = None


class ListAnalyzedResourcesRequest(BaseModel):
    analyzerArn: AnalyzerArn
    maxResults: Optional[Integer] = None
    nextToken: Optional[Token] = None
    resourceType: Optional[ResourceType] = None


class ListAnalyzedResourcesResponse(BaseModel):
    analyzedResources: AnalyzedResourcesList
    nextToken: Optional[Token] = None


class ListAnalyzersResponse(BaseModel):
    analyzers: AnalyzersList
    nextToken: Optional[Token] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagsMap] = None


class PathElement(BaseModel):
    index: Optional[Integer] = None
    key: Optional[String] = None
    substring: Optional[Substring] = None
    value: Optional[String] = None


class PathElementList(RootModel[List[PathElement]]):
    root: List[PathElement]


class PolicyGeneration(BaseModel):
    completedOn: Optional[Timestamp] = None
    jobId: JobId
    principalArn: PrincipalArn
    startedOn: Timestamp
    status: JobStatus


class PolicyGenerationDetails(BaseModel):
    principalArn: PrincipalArn


class PolicyGenerationList(RootModel[List[PolicyGeneration]]):
    root: List[PolicyGeneration]


class PrincipalMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class RdsDbClusterSnapshotConfiguration(BaseModel):
    attributes: Optional[RdsDbClusterSnapshotAttributesMap] = None
    kmsKeyId: Optional[RdsDbClusterSnapshotKmsKeyId] = None


class RdsDbSnapshotConfiguration(BaseModel):
    attributes: Optional[RdsDbSnapshotAttributesMap] = None
    kmsKeyId: Optional[RdsDbSnapshotKmsKeyId] = None


class RegionList(RootModel[List[String]]):
    root: List[String]


class S3BucketAclGrantConfiguration(BaseModel):
    grantee: AclGrantee
    permission: AclPermission


class S3BucketAclGrantConfigurationsList(
    RootModel[List[S3BucketAclGrantConfiguration]]
):
    root: List[S3BucketAclGrantConfiguration]


class SecretsManagerSecretConfiguration(BaseModel):
    kmsKeyId: Optional[SecretsManagerSecretKmsId] = None
    secretPolicy: Optional[SecretsManagerSecretPolicy] = None


class SharedViaList(RootModel[List[String]]):
    root: List[String]


class SnsTopicConfiguration(BaseModel):
    topicPolicy: Optional[SnsTopicPolicy] = None


class SortCriteria(BaseModel):
    attributeName: Optional[String] = None
    orderBy: Optional[OrderBy] = None


class SqsQueueConfiguration(BaseModel):
    queuePolicy: Optional[SqsQueuePolicy] = None


class StartResourceScanRequest(BaseModel):
    analyzerArn: AnalyzerArn
    resourceArn: ResourceArn
    resourceOwnerAccount: Optional[String] = None


class TagResourceRequest(BaseModel):
    tags: TagsMap


class Trail(BaseModel):
    allRegions: Optional[Boolean] = None
    cloudTrailArn: CloudTrailArn
    regions: Optional[RegionList] = None


class TrailList(RootModel[List[Trail]]):
    root: List[Trail]


class TrailProperties(BaseModel):
    allRegions: Optional[Boolean] = None
    cloudTrailArn: CloudTrailArn
    regions: Optional[RegionList] = None


class TrailPropertiesList(RootModel[List[TrailProperties]]):
    root: List[TrailProperties]


class UpdateArchiveRuleRequest(BaseModel):
    clientToken: Optional[String] = None
    filter: FilterCriteriaMap


class ValidatePolicyRequest(BaseModel):
    locale: Optional[Locale] = None
    policyDocument: PolicyDocument
    policyType: PolicyType
    validatePolicyResourceType: Optional[ValidatePolicyResourceType] = None


class VpcConfiguration(BaseModel):
    vpcId: VpcId


class AccessPreviewAccessPreviewIdPostRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> used to generate the access.',
        )
    )
    filter: Optional[Dict[str, Criterion]] = Field(
        None, description='Criteria to filter the returned findings.'
    )
    maxResults: Optional[int] = Field(
        None, description='The maximum number of results to return in the response.'
    )
    nextToken: Optional[str] = Field(
        None, description='A token used for pagination of results returned.'
    )


class AnalyzerPutRequest(BaseModel):
    analyzerName: constr(
        pattern=r'[A-Za-z][A-Za-z0-9_.-]*', min_length=1, max_length=255
    ) = Field(..., description='The name of the analyzer to create.')
    archiveRules: Optional[List[InlineArchiveRule]] = Field(
        None,
        description='Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.',
    )
    clientToken: Optional[str] = Field(None, description='A client token.')
    tags: Optional[Dict[str, String]] = Field(
        None, description='The tags to apply to the analyzer.'
    )
    type: Type = Field(
        ...,
        description='The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.',
    )


class AnalyzerAnalyzerNameArchiveRulePutRequest(BaseModel):
    clientToken: Optional[str] = Field(None, description='A client token.')
    filter: Dict[str, Criterion] = Field(..., description='The criteria for the rule.')
    ruleName: constr(
        pattern=r'[A-Za-z][A-Za-z0-9_.-]*', min_length=1, max_length=255
    ) = Field(..., description='The name of the rule to create.')


class AnalyzerAnalyzerNameArchiveRuleRuleNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(None, description='A client token.')
    filter: Dict[str, Criterion] = Field(
        ...,
        description='A filter to match for the rules to update. Only rules that match the filter are updated.',
    )


class FindingPostRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to retrieve findings from.',
        )
    )
    filter: Optional[Dict[str, Criterion]] = Field(
        None, description='A filter to match for the findings to return.'
    )
    maxResults: Optional[int] = Field(
        None, description='The maximum number of results to return in the response.'
    )
    nextToken: Optional[str] = Field(
        None, description='A token used for pagination of results returned.'
    )
    sort: Optional[Sort] = Field(None, description='The criteria used to sort.')


class CloudTrailDetails1(BaseModel):
    accessRole: Optional[RoleArn] = None
    endTime: Optional[Timestamp] = None
    startTime: Optional[Timestamp] = None
    trails: Optional[TrailList] = None


class PolicyGenerationPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='<p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect.</p> <p>If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.</p>',
    )
    cloudTrailDetails: Optional[CloudTrailDetails1] = Field(
        None, description='Contains information about CloudTrail access.'
    )
    policyGenerationDetails: PolicyGenerationDetails1 = Field(
        ...,
        description='Contains the ARN details about the IAM entity for which the policy is generated.',
    )


class AnalyzedResource(BaseModel):
    actions: Optional[ActionList] = None
    analyzedAt: Timestamp
    createdAt: Timestamp
    error: Optional[String] = None
    isPublic: Boolean
    resourceArn: ResourceArn
    resourceOwnerAccount: String
    resourceType: ResourceType
    sharedVia: Optional[SharedViaList] = None
    status: Optional[FindingStatus] = None
    updatedAt: Timestamp


class ArchiveRuleSummary(BaseModel):
    createdAt: Timestamp
    filter: FilterCriteriaMap
    ruleName: Name
    updatedAt: Timestamp


class ArchiveRulesList(RootModel[List[ArchiveRuleSummary]]):
    root: List[ArchiveRuleSummary]


class CloudTrailDetails(BaseModel):
    accessRole: RoleArn
    endTime: Optional[Timestamp] = None
    startTime: Timestamp
    trails: TrailList


class CloudTrailProperties(BaseModel):
    endTime: Timestamp
    startTime: Timestamp
    trailProperties: TrailPropertiesList


class CreateAnalyzerRequest(BaseModel):
    analyzerName: Name
    archiveRules: Optional[InlineArchiveRulesList] = None
    clientToken: Optional[String] = None
    tags: Optional[TagsMap] = None
    type: Type


class CreateArchiveRuleRequest(BaseModel):
    clientToken: Optional[String] = None
    filter: FilterCriteriaMap
    ruleName: Name


class FindingSource(BaseModel):
    detail: Optional[FindingSourceDetail] = None
    type: FindingSourceType


class FindingSourceList(RootModel[List[FindingSource]]):
    root: List[FindingSource]


class FindingSummary(BaseModel):
    action: Optional[ActionList] = None
    analyzedAt: Timestamp
    condition: ConditionKeyMap
    createdAt: Timestamp
    error: Optional[String] = None
    id: FindingId
    isPublic: Optional[Boolean] = None
    principal: Optional[PrincipalMap] = None
    resource: Optional[String] = None
    resourceOwnerAccount: String
    resourceType: ResourceType
    sources: Optional[FindingSourceList] = None
    status: FindingStatus
    updatedAt: Timestamp


class FindingsList(RootModel[List[FindingSummary]]):
    root: List[FindingSummary]


class GeneratedPolicyProperties(BaseModel):
    cloudTrailProperties: Optional[CloudTrailProperties] = None
    isComplete: Optional[Boolean] = None
    principalArn: PrincipalArn


class GetAnalyzedResourceResponse(BaseModel):
    resource: Optional[AnalyzedResource] = None


class GetArchiveRuleResponse(BaseModel):
    archiveRule: ArchiveRuleSummary


class JobDetails(BaseModel):
    completedOn: Optional[Timestamp] = None
    jobError: Optional[JobError] = None
    jobId: JobId
    startedOn: Timestamp
    status: JobStatus


class KmsGrantConfiguration(BaseModel):
    constraints: Optional[KmsGrantConstraints] = None
    granteePrincipal: GranteePrincipal
    issuingAccount: IssuingAccount
    operations: KmsGrantOperationsList
    retiringPrincipal: Optional[RetiringPrincipal] = None


class KmsGrantConfigurationsList(RootModel[List[KmsGrantConfiguration]]):
    root: List[KmsGrantConfiguration]


class KmsKeyConfiguration(BaseModel):
    grants: Optional[KmsGrantConfigurationsList] = None
    keyPolicies: Optional[KmsKeyPoliciesMap] = None


class ListArchiveRulesResponse(BaseModel):
    archiveRules: ArchiveRulesList
    nextToken: Optional[Token] = None


class ListFindingsRequest(BaseModel):
    analyzerArn: AnalyzerArn
    filter: Optional[FilterCriteriaMap] = None
    maxResults: Optional[Integer] = None
    nextToken: Optional[Token] = None
    sort: Optional[SortCriteria] = None


class ListFindingsResponse(BaseModel):
    findings: FindingsList
    nextToken: Optional[Token] = None


class ListPolicyGenerationsResponse(BaseModel):
    nextToken: Optional[Token] = None
    policyGenerations: PolicyGenerationList


class Location(BaseModel):
    path: PathElementList
    span: Span


class LocationList(RootModel[List[Location]]):
    root: List[Location]


class NetworkOriginConfiguration(BaseModel):
    internetConfiguration: Optional[InternetConfiguration] = None
    vpcConfiguration: Optional[VpcConfiguration] = None


class S3AccessPointConfiguration(BaseModel):
    accessPointPolicy: Optional[AccessPointPolicy] = None
    networkOrigin: Optional[NetworkOriginConfiguration] = None
    publicAccessBlock: Optional[S3PublicAccessBlockConfiguration] = None


class S3AccessPointConfigurationsMap(
    RootModel[Optional[Dict[str, S3AccessPointConfiguration]]]
):
    root: Optional[Dict[str, S3AccessPointConfiguration]] = None


class S3BucketConfiguration(BaseModel):
    accessPoints: Optional[S3AccessPointConfigurationsMap] = None
    bucketAclGrants: Optional[S3BucketAclGrantConfigurationsList] = None
    bucketPolicy: Optional[S3BucketPolicy] = None
    bucketPublicAccessBlock: Optional[S3PublicAccessBlockConfiguration] = None


class StartPolicyGenerationRequest(BaseModel):
    clientToken: Optional[String] = None
    cloudTrailDetails: Optional[CloudTrailDetails] = None
    policyGenerationDetails: PolicyGenerationDetails


class ValidatePolicyFinding(BaseModel):
    findingDetails: String
    findingType: ValidatePolicyFindingType
    issueCode: IssueCode
    learnMoreLink: LearnMoreLink
    locations: LocationList


class ValidatePolicyFindingList(RootModel[List[ValidatePolicyFinding]]):
    root: List[ValidatePolicyFinding]


class ValidatePolicyResponse(BaseModel):
    findings: ValidatePolicyFindingList
    nextToken: Optional[Token] = None


class AccessPreviewFinding(BaseModel):
    action: Optional[ActionList] = None
    changeType: FindingChangeType
    condition: Optional[ConditionKeyMap] = None
    createdAt: Timestamp
    error: Optional[String] = None
    existingFindingId: Optional[FindingId] = None
    existingFindingStatus: Optional[FindingStatus] = None
    id: AccessPreviewFindingId
    isPublic: Optional[Boolean] = None
    principal: Optional[PrincipalMap] = None
    resource: Optional[String] = None
    resourceOwnerAccount: String
    resourceType: ResourceType
    sources: Optional[FindingSourceList] = None
    status: FindingStatus


class AccessPreviewFindingsList(RootModel[List[AccessPreviewFinding]]):
    root: List[AccessPreviewFinding]


class Configuration(BaseModel):
    ebsSnapshot: Optional[EbsSnapshotConfiguration] = None
    ecrRepository: Optional[EcrRepositoryConfiguration] = None
    efsFileSystem: Optional[EfsFileSystemConfiguration] = None
    iamRole: Optional[IamRoleConfiguration] = None
    kmsKey: Optional[KmsKeyConfiguration] = None
    rdsDbClusterSnapshot: Optional[RdsDbClusterSnapshotConfiguration] = None
    rdsDbSnapshot: Optional[RdsDbSnapshotConfiguration] = None
    s3Bucket: Optional[S3BucketConfiguration] = None
    secretsManagerSecret: Optional[SecretsManagerSecretConfiguration] = None
    snsTopic: Optional[SnsTopicConfiguration] = None
    sqsQueue: Optional[SqsQueueConfiguration] = None


class ConfigurationsMap(RootModel[Optional[Dict[str, Configuration]]]):
    root: Optional[Dict[str, Configuration]] = None


class CreateAccessPreviewRequest(BaseModel):
    analyzerArn: AnalyzerArn
    clientToken: Optional[String] = None
    configurations: ConfigurationsMap


class Finding(BaseModel):
    action: Optional[ActionList] = None
    analyzedAt: Timestamp
    condition: ConditionKeyMap
    createdAt: Timestamp
    error: Optional[String] = None
    id: FindingId
    isPublic: Optional[Boolean] = None
    principal: Optional[PrincipalMap] = None
    resource: Optional[String] = None
    resourceOwnerAccount: String
    resourceType: ResourceType
    sources: Optional[FindingSourceList] = None
    status: FindingStatus
    updatedAt: Timestamp


class GetFindingResponse(BaseModel):
    finding: Optional[Finding] = None


class GetGeneratedPolicyResponse(BaseModel):
    generatedPolicyResult: GeneratedPolicyResult
    jobDetails: JobDetails


class ListAccessPreviewFindingsResponse(BaseModel):
    findings: AccessPreviewFindingsList
    nextToken: Optional[Token] = None


class AccessPreviewPutRequest(BaseModel):
    analyzerArn: constr(pattern=r'[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}') = (
        Field(
            ...,
            description='The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the account analyzer</a> used to generate the access preview. You can only create an access preview for analyzers with an <code>Account</code> type and <code>Active</code> status.',
        )
    )
    clientToken: Optional[str] = Field(None, description='A client token.')
    configurations: Dict[str, Configuration] = Field(
        ...,
        description='Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.',
    )


class AccessPreview(BaseModel):
    analyzerArn: AnalyzerArn
    configurations: ConfigurationsMap
    createdAt: Timestamp
    id: AccessPreviewId
    status: AccessPreviewStatus
    statusReason: Optional[AccessPreviewStatusReason] = None


class GetAccessPreviewResponse(BaseModel):
    accessPreview: AccessPreview
